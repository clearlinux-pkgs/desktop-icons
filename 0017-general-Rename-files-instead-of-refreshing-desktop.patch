From d11f0311db4af207e02d40b14ebd34229d2c52e6 Mon Sep 17 00:00:00 2001
From: Sergio Costas <raster@rastersoft.com>
Date: Sun, 28 Oct 2018 12:12:29 +0100
Subject: [PATCH 17/55] general: Rename files instead of refreshing desktop

When a file was renamed, the extension forced a full desktop rebuild, which
results in flicker and CPU usage.

This patch modifies both desktopManager.js and fileItem.js to manage directly
the RENAME events from desktopManager and ask the corresponding fileItem to
update its name on-the-fly. Also, this patch sets the basis for future direct
event management, like adding or deleting files on-the-fly.
---
 desktopManager.js | 53 +++++++++++++++++++++++++----------
 fileItem.js       | 70 +++++++++++++++++++++++++++++++++++------------
 2 files changed, 91 insertions(+), 32 deletions(-)

diff --git a/desktopManager.js b/desktopManager.js
index b6cfb7b..6814d1c 100644
--- a/desktopManager.js
+++ b/desktopManager.js
@@ -61,7 +61,7 @@ var DesktopManager = class {
         this._desktopMonitorCancellable = null;
         this._desktopGrids = {};
         this._fileItemHandlers = new Map();
-        this._fileItems = [];
+        this._fileItems = new Map();
         this._dragCancelled = false;
 
         this._monitorsChangedId = Main.layoutManager.connect('monitors-changed', () => this._recreateDesktopIcons());
@@ -113,7 +113,7 @@ var DesktopManager = class {
                 y1 = this._rubberBandInitialY;
                 y0 = y;
             }
-            for(let fileItem of this._fileItems) {
+            for(let [fileUri, fileItem] of this._fileItems) {
                 fileItem.emit('selected', true,
                               fileItem.intersectsWith(x0, y0, x1 - x0, y1 - y0));
             }
@@ -173,12 +173,12 @@ var DesktopManager = class {
         for (let [fileItem, id] of this._fileItemHandlers)
             fileItem.disconnect(id);
         this._fileItemHandlers = new Map();
-        this._fileItems = [];
+        this._fileItems = new Map();
 
         try {
             for (let [file, info, extra] of await this._enumerateDesktop()) {
                 let fileItem = new FileItem.FileItem(file, info, extra);
-                this._fileItems.push(fileItem);
+                this._fileItems.set(fileItem.file.get_uri(), fileItem);
                 let id = fileItem.connect('selected',
                                           this._onFileItemSelected.bind(this));
 
@@ -241,13 +241,36 @@ var DesktopManager = class {
     }
 
     _updateDesktopIfChanged (file, otherFile, eventType) {
-        // Only get a subset of events we are interested in.
-        // Note that CREATED will emit a CHANGES_DONE_HINT
         let {
-            CHANGES_DONE_HINT, DELETED, RENAMED, MOVED_IN, MOVED_OUT, CREATED
+            DELETED, MOVED_IN, MOVED_OUT, CREATED, RENAMED, CHANGES_DONE_HINT, ATTRIBUTE_CHANGED
         } = Gio.FileMonitorEvent;
-        if (![CHANGES_DONE_HINT, DELETED, RENAMED,
-            MOVED_IN, MOVED_OUT, CREATED].includes(eventType))
+
+        let fileUri = file.get_uri();
+        let fileItem = null;
+        if (this._fileItems.has(fileUri))
+            fileItem = this._fileItems.get(fileUri);
+        switch(eventType) {
+            case RENAMED:
+                this._fileItems.delete(fileUri);
+                this._fileItems.set(otherFile.get_uri(), fileItem);
+                fileItem.renamed(otherFile);
+                return;
+            case CHANGES_DONE_HINT:
+            case ATTRIBUTE_CHANGED:
+                // FIXME: ATTRIBUTE_CHANGED wasn't managed in the old code; in the future, it must be managed
+                return;
+        }
+
+        // Rate limiting isn't enough, as one action will create different events on the same file.
+        // limit by adding a timeout
+        if (this._scheduleDesktopsRefreshId) {
+            return;
+        }
+
+        // Only get a subset of events we are interested in.
+        // Note that CREATED will emit a CHANGES_DONE_HINT
+
+        if (![DELETED, MOVED_IN, MOVED_OUT, CREATED].includes(eventType))
             return;
 
         this._recreateDesktopIcons();
@@ -494,7 +517,7 @@ var DesktopManager = class {
          * * first pass paints those that have their coordinates defined in the metadata
          * * second pass paints those new files that still don't have their definitive coordinates
          */
-        for (let fileItem of this._fileItems) {
+        for (let [fileUri, fileItem] of this._fileItems) {
             if (fileItem.savedCoordinates == null)
                 continue;
             if (fileItem.state != FileItem.State.NORMAL)
@@ -504,7 +527,7 @@ var DesktopManager = class {
             this._addFileItemCloseTo(fileItem);
         }
 
-        for (let fileItem of this._fileItems) {
+        for (let [fileUri, fileItem] of this._fileItems) {
             if (fileItem.savedCoordinates !== null)
                 continue;
             if (fileItem.state != FileItem.State.NORMAL)
@@ -540,6 +563,7 @@ var DesktopManager = class {
     }
 
     _onFileItemSelected(fileItem, keepCurrentSelection, addToSelection) {
+
         if (!keepCurrentSelection && !this._inDrag)
             this.clearSelection();
 
@@ -548,14 +572,13 @@ var DesktopManager = class {
         else
             this._selection.delete(fileItem);
 
-        this._fileItems.forEach(f => f.isSelected = this._selection.has(f));
+        for(let [fileUri, fileItem] of this._fileItems)
+            fileItem.isSelected = this._selection.has(fileItem);
     }
 
     clearSelection() {
-        for (let fileItem of this._fileItems) {
+        for (let [fileUri, fileItem] of this._fileItems)
             fileItem.isSelected = false;
-        }
-
         this._selection = new Set();
     }
 
diff --git a/fileItem.js b/fileItem.js
index dd16a1b..6b735e0 100644
--- a/fileItem.js
+++ b/fileItem.js
@@ -63,11 +63,12 @@ var FileItem = class {
         this._loadThumbnailDataCancellable = null;
         this._thumbnailScriptWatch = 0;
         this._setMetadataCancellable = null;
+        this._queryFileInfoCancellable = null;
+        this._isSpecial = this._fileExtra != Prefs.FILE_TYPE.NONE;
 
         let scaleFactor = St.ThemeContext.get_for_stage(global.stage).scale_factor;
 
         this._file = file;
-        this._fileInfo = fileInfo;
         let savedCoordinates = fileInfo.get_attribute_as_string('metadata::nautilus-icon-position');
 
         if (savedCoordinates != null)
@@ -75,18 +76,9 @@ var FileItem = class {
         else
             this._savedCoordinates = null;
 
-        this._attributeCanExecute = fileInfo.get_attribute_boolean('access::can-execute');
-        this._fileType = fileInfo.get_file_type();
-        this._isDirectory = this._fileType == Gio.FileType.DIRECTORY;
-        this._isSpecial = this._fileExtra != Prefs.FILE_TYPE.NONE;
-        this._attributeContentType = fileInfo.get_content_type();
-        this._isDesktopFile = this._attributeContentType == 'application/x-desktop';
-        this._isSymlink = fileInfo.get_is_symlink();
-        this._fileUri = this._file.get_uri();
-        this._filePath = this._file.get_path();
-        this._modifiedTime = this._fileInfo.get_attribute_uint64('time::modified');
+        this._updateMetadataFromFileInfo(fileInfo);
+
         this._state = State.NORMAL;
-        this._displayName = fileInfo.get_attribute_as_string('standard::display-name');
 
         this.actor = new St.Bin({ visible: true });
         this.actor.set_fill(true, true);
@@ -168,6 +160,8 @@ var FileItem = class {
         /* Regular file data */
         if (this._setMetadataCancellable)
             this._setMetadataCancellable.cancel();
+        if (this._queryFileInfoCancellable)
+            this._queryFileInfoCancellable.cancel();
 
         /* Thumbnailing */
         if (this._thumbnailScriptWatch)
@@ -184,6 +178,49 @@ var FileItem = class {
             GLib.source_remove(this._scheduleTrashRefreshId);
     }
 
+    _updateMetadataFromFileInfo(fileInfo) {
+        this._fileInfo = fileInfo;
+        this._displayName = fileInfo.get_attribute_as_string('standard::display-name');
+        this._attributeCanExecute = fileInfo.get_attribute_boolean('access::can-execute');
+        this._fileType = fileInfo.get_file_type();
+        this._isDirectory = this._fileType == Gio.FileType.DIRECTORY;
+        this._isSpecial = this._fileExtra != Prefs.FILE_TYPE.NONE;
+        this._attributeContentType = fileInfo.get_content_type();
+        this._isDesktopFile = this._attributeContentType == 'application/x-desktop';
+        this._attributeHidden = fileInfo.get_is_hidden();
+        this._isSymlink = fileInfo.get_is_symlink();
+        this._modifiedTime = this._fileInfo.get_attribute_uint64("time::modified");
+    }
+
+    _updateFromFileInfo(newFileInfo) {
+        let oldDisplayName = this._displayName;
+        this._updateMetadataFromFileInfo(newFileInfo);
+        if (this._displayName != oldDisplayName) {
+            this._label.text = this._displayName;
+        }
+    }
+
+    renamed(file) {
+        if (this._queryFileInfoCancellable)
+            this._queryFileInfoCancellable.cancel();
+        this._queryFileInfoCancellable = new Gio.Cancellable();
+        this._file = file;
+        file.query_info_async(DesktopIconsUtil.DEFAULT_ATTRIBUTES,
+                              Gio.FileQueryInfoFlags.NONE,
+                              GLib.PRIORITY_DEFAULT,
+                              this._queryFileInfoCancellable,
+            (source, res) => {
+                try {
+                    let newFileInfo = source.query_info_finish(res);
+                    this._queryFileInfoCancellable = null;
+                    this._updateFromFileInfo(newFileInfo);
+                } catch(error) {
+                    if (!error.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED))
+                        global.log("Error getting the file info: " + error);
+                }
+            });
+    }
+
     _updateIcon() {
         if (this._fileExtra == Prefs.FILE_TYPE.USER_DIRECTORY_TRASH) {
             this._icon.child = this._createEmblemedStIcon(this._fileInfo.get_icon(), null);
@@ -191,17 +228,17 @@ var FileItem = class {
         }
 
         let thumbnailFactory = GnomeDesktop.DesktopThumbnailFactory.new(GnomeDesktop.DesktopThumbnailSize.LARGE);
-        if (thumbnailFactory.can_thumbnail(this._fileUri,
+        if (thumbnailFactory.can_thumbnail(this._file.get_uri(),
                                            this._attributeContentType,
                                            this._modifiedTime)) {
-            let thumbnail = thumbnailFactory.lookup(this._fileUri, this._modifiedTime);
+            let thumbnail = thumbnailFactory.lookup(this._file.get_uri(), this._modifiedTime);
             if (thumbnail == null) {
-                if (!thumbnailFactory.has_valid_failed_thumbnail(this._fileUri,
+                if (!thumbnailFactory.has_valid_failed_thumbnail(this._file.get_uri(),
                                                                  this._modifiedTime)) {
                     let argv = [];
                     argv.push(GLib.build_filenamev([ExtensionUtils.getCurrentExtension().path,
                                                    'createThumbnail.js']));
-                    argv.push(this._filePath);
+                    argv.push(this._file.get_path());
                     let [success, pid] = GLib.spawn_async(null, argv, null,
                                                           GLib.SpawnFlags.SEARCH_PATH | GLib.SpawnFlags.DO_NOT_REAP_CHILD, null);
                     if (this._thumbnailScriptWatch)
@@ -300,7 +337,6 @@ var FileItem = class {
     }
 
     _createEmblemedStIcon(icon, iconName) {
-
         if (icon == null) {
             if (GLib.path_is_absolute(iconName)) {
                 let iconFile = Gio.File.new_for_commandline_arg(iconName);
-- 
2.20.0

